{"meta":{"title":"xiaoyu","subtitle":null,"description":null,"author":"xiaoyu","url":"https://ydmxiaoyu.github.io","root":"/"},"pages":[{"title":"About","date":"2019-05-29T10:15:06.000Z","updated":"2019-06-15T02:25:28.615Z","comments":true,"path":"about/index.html","permalink":"https://ydmxiaoyu.github.io/about/index.html","excerpt":"","text":"about me从事服务端开发，主要使用java语言，熟悉Spring、Spring boot、Mybatis等主流开发框架，轻度代码洁癖。 对服务端、前端有所了解 热爱开源项目、新技术 about work工作城市：广州 about study知识无止境，越努力，越幸运近期学习方向：微服务、分布式 about habit喜爱羽毛球、阅读、科幻电影、旅行 contact me github: xiaoyu"}],"posts":[{"title":"dns解析原理","slug":"dns解析原理","date":"2019-08-11T16:00:00.000Z","updated":"2019-08-19T08:19:02.659Z","comments":true,"path":"2019/08/12/dns解析原理/","link":"","permalink":"https://ydmxiaoyu.github.io/2019/08/12/dns解析原理/","excerpt":"","text":"DNS递归解析原理 “递归解析”（或叫“递归查询”，其实意思是一样的）是最常见，也是默认的解析方式。在这种解析方式中，如果客户端配置的本地名称服务器不能解析的话，则后面的查询全由本地名称服务器代替DNS客户端进行查询，直到本地名称服务器从权威名称服务器得到了正确的解析结果，然后由本地名称服务器告诉DNS客户端查询的结果。 DNS递归解析基本流程 在这个查询过程中，一直是以本地名称服务器为中心的，DNS客户端只是发出原始的域名查询请求报文，然后就一直处于等待状态的，直到本地名称服务器发来了最终的查询结果。此时的本地名称服务器就相当于中介代理的作用。如果考虑了本地名称服务器的缓存技术（也就是在DNS服务器上对一定数量的以前查询记录保存一定时间，这样后面查询同样的域名信息时就可直接从缓存中调出来，以加速查询效率）的话，则递归解析的基本流程如下： （1）客户端向本机配置的本地名称服务器（在此仅以首选DNS服务器为例进行介绍，所配置其它备用DNS服务器的解析流程完全一样）发出DNS域名查询请求。 （2）本地名称服务器收到请求后，先查询本地的缓存，如果有该域名的记录项，则本地名称服务器就直接把查询的结果返回给客户端；如果本地缓存中没有该域名的记录，则本地名称服务器再以DNS客户端的角色发送与前面一样的DNS域名查询请求发给根名称服务器。 （3）根名称服务器收到DNS请求后，把所查询得到的所请求的DNS域名中顶级域名所对应的顶级名称服务器地址返回给本地名称服务器。 （4）本地名称服务器根据根名称服务器所返回的顶级名称服务器地址，向对应的顶级名称服务器发送与前面一样的DNS域名查询请求。 （5）对应的顶级名称服务器在收到DNS查询请求后，也是先查询自己的缓存，如果有所请求的DNS域名的记录项，则相接把对应的记录项返回给本地名称服务器，然后再由本地名称服务器返回给DNS客户端，否则向本地名称服务器返回所请求的DNS域名中的二级域名所对应的二级名称服务器地址。 然后本地名称服务器继续按照前面介绍的方法一次次地向三级、四级名称服务器查询，直到最终的对应域名所在区域的权威名称服务器返回到最终的记录给本地名称服务器。然后再由本地名称服务器返回给DNS客户，同时本地名称服务器会缓存本次查询得到的记录项。 DNS递归解析示例 为了方便大家理解，下面举一个实例进行介绍。本示例中假设客户端想要访问自己并不识别的example.microsoft.com站点，并假设此客户端配置的本地名称服务器假设为dns.company.com（通常是以IP地址方式配置的），本地名称服务器上配置的根名称服务器是a.rootserver.net。整个递归名称解析过程如图11-15所示（其中的Q1~Q5表示发送DNS查询请求，A1~A5是DNS查询应答），具体描述如下： （1）DNS客户端向所配置的本地名称服务器dns.company.com发出解析example.microsoft.com域名的DNS请求报文（图中的Q1）。相当于对本地名称服务器说“请给我example.microsoft.com所对应的IP地址”。 （2）本地名称服务器收到请求后，先查询本地缓存。假设没有查到该域名对应记录，则本地名称服务器向所配置的根名称服务器a.rootserver.net发出解析请求解析example.microsoft.com域名的DNS请求报文（图中的Q2）。 （3）根名称服务器收到查询请求后，通过查询得到.com顶级域名所对应的顶级名称服务器，然后向本地名称服务器返回一条应答报文（图中的A1）。相当说“我不知道example.microsoft.com域名所对应的IP地址，但我现在告诉你.com域名所对应的顶级名称服务器地址”。 图11-15 DNS递归名称解析示例 （4）本地名称服务器在收到根名称服务器的DNS应答报文，得到.com顶级域名所对应的顶级名称服务器地址后，再次向对应的顶级名称服务器发送一条请求解析example.microsoft.com域名的DNS请求报文（图中的Q3）。 （5）.com顶级名称服务器在收到DNS请求报文后，先查询自己的缓存，假设也没有该域名的记录项，则查询microsoft.com所对应的二级名称服务器，然后也向本地名称服务返回一条DNS应答报文（图中的A2）。相当于说“我不知道example.microsoft.com域名所对应的IP地址，但我现在告诉你microsoft.com域名所对应的二级名称服务器地址”。 （6）本地名称服务器在收到.com顶级名称服务器的DNS应答报文，得到microsoft.com二级域名所对应的二级名称服务器地址后，再次向对应的二级名称服务器发送一条请求解析example.microsoft.com域名的DNS请求报文（图中的Q4）。 （7）microsoft.com二级名称服务器在收到DNS请求报文后，也先查询自己的缓存，假设也没有该域名的记录项，则查询example.microsoft.com所对应的权威名称服务器（因为这个名称服务器已包括了完整域名example.microsoft.com所在区域），然后也向本地名称服务器返回一条DNS应答报文（图中的A3）。相当于说“我不知道example.microsoft.com域名所对应的IP地址，但我现在告诉你example.microsoft.com域名所对应的权威名称服务器地址”。 （8）本地名称服务器在收到microsoft.com二级名称服务器的DNS应答报文，得到example.microsoft.com三级域名所对应的权威名称服务器地址后，再次向对应的权威名称服务器发送一条请求解析example.microsoft.com域名的DNS请求报文（图中的Q5）。 （9）权威名称服务器在收到DNS请求后，在它的DNS区域数据库中查找，最终得出了example.microsoft.com域名所对应的IP地址。然后向本地名称服务器返回到条DNS应答报文（图中的A4）。相当于说“example.microsoft.com域名的IP地址为xxx.xxx.xxx.xxx”。 （10）本地名称服务器在收到权威名称服务器后，向DNS客户端返回一条DNS应答报文（图中的A5），告诉DNS客户端所得到的example.microsoft.com域名的IP地址。这样DNS客户端就可以正常访问这个网站了。 如果在步骤（9）中的对应域名的权威名称服务器都说找不到对应的域名记录，则会向本地名称服务器返回一条查询失败的DNS应答报文，这条报文最终也会由本地名称服务器返回给DNS客户端。当然，如果这个权威名称服务器上配置了指向其它名称服务器的转发器，则权威名称服务器还会在转发器指向的名称服务器上进一步查询。另外，如果DNS客户端上配置了多个DNS服务器，则还会继续向其它DNS服务器查询的。 11.3.8 DNS迭代名称解析原理 在上节介绍的DNS递归名称解析中，当所配置的本地名称服务器解析不了时，后面的查询工作是由本地名称服务器替代DNS客户端进行的（以“本地名称服务器”为中心），只需要本地名称服务器向DNS客户端返回最终的查询结果即可。而本节所介绍的DNS迭代名称解析（或者叫“迭代查询”）的所有查询工作全部是DNS客户端自己进行（以“DNS客户端”自己为中心）。在条件之一满足时就会采用迭代名称解析方式： l 在查询本地名称服务器时，如果客户端的请求报文中没有申请使用递归查询，即在DNS请求报头部的RD字段没有置1。相当于说“你都没有主动要求我为你进行递归查询，我当然不会为你工作了”。 l 客户端在DNS请求报文中申请使用的是递归查询（也就是RD字段置1了），但在所配置的本地名称服务器上是禁用递归查询（DNS服务器一般默认支持递归查询的），即在应答DNS报文头部的RA字段置0。 迭代名称解析的基本流程 使用迭代解析方式时，如果它所配置的主名称服务器（如Windows系统中的“首选DNS服务器”）不能解析的话，客户端还会继续向所配置的其它名称服务器（如Windows系统中的“备用DNS服务器”）查询。迭代名称解析的基本流程如下： （1）客户端向本机配置的本地名称服务器（在此仅以首先DNS服务器为例进行介绍，其它备用DNS服务器的解析流程完全一样）发出DNS域名查询请求。 （2）本地名称服务器收到请求后，先查询本地的缓存，如果有该域名的记录项，则本地名称服务器就直接把查询的结果返回给客户端；如果本地缓存中没有该域名的记录，则向DNS客户端返回一条DNS应答报文，报文中会给出一些参考信息，如本地名称服务器上的根名称服务器地址等。 （3）DNS客户端在收到本地名称服务器的应答报文后，会根据其中的根名称服务器地址信息，向对应的根名称服务器再次发出与前面一样的DNS查询请求报文。 （4）根名称服务器在收到DNS查询请求报文后，通过查询自己的DNS数据库得到请求DNS域名中顶级域名所对应的顶级名称服务器信息，然后以一条DNS应答报文返回给DNS客户端。 （5）DNS客户端根据来自根名称服务器应答报文中的对应顶级名称服务器地址信息，向该顶级名称服务器发出与前面一样的DNS查询请求报文。 （6）顶级名称服务器在收到DNS查询请求后，先查询自己的缓存，如果有所请求的DNS域名的记录项，则相接把对应的记录项返回给DNS客户端，否则通过查询后把对应域名中二级域名所对应的二级名称服务器地址信息以一条DNS应答报文返回给DNS客户端。 然后DNS客户端继续按照前面介绍的方法一次次地向三级、四级名称服务器查询，直到最终的权威名称服务器返回到最终的记录。 DNS迭代解析示例 同样，为了方便大家理解，也例举一个具体的示例，看一下DNS迭代解析的工作流程。本示例也与上节介绍的DNS递归解析一样，假设客户端想要访问自己并不识别的example.microsoft.com站点，并假设此客户端配置的本地名称服务器假设为dns.company.com（仅以一个为例进行介绍），在该本地名称服务器上配置的根名称服务器是a.rootserver.net。整个迭代名称解析过程如图11-16所示（其中的Q1~Q5表示发送DNS查询请求，A1~A5是对应序号DNS查询请求的应答），具体描述如下： 图11-16 DNS迭代名称解析示例 （1）DNS客户端向所配置的本地名称服务器dns.company.com发出解析example.microsoft.com域名的DNS请求报文（图中的Q1）。 （2）本地名称服务器收到DNS客户端的DNS查询请求报文后，先查询本地缓存。假设没有查到该域名对应记录，则本地名称服务器把所配置的根名称服务器a.rootserver.net地址信息以DNS应答报文返回给DNS客户端（图中和A1）。 （3）DNS客户端在收到本地名称服务器的DNS应答报文后，根据其中给出的根名称服务器地址信息，向对应的根名称服务器再次发送解析example.microsoft.com域名的DNS请求报文（图中的Q2）。 （4）根名称服务器在收到DNS查询请求后，通过查询得到.com顶级域名所对应的顶级名称服务器，然后把查询到的对应顶级域名信息以一条DNS应答报文返回给DNS客户端（图中的A2）。 （5）DNS客户端在收到根名称服务器的DNS应答报文，得到.com顶级域名所对应的顶级名称服务器地址后，再次向对应的顶级名称服务器发送一条解析example.microsoft.com域名的的DNS请求报文（图中的Q3）。 （6）.com顶级名称服务器在收到DNS客户端的DNS查询请求报文后，先查询自己的缓存，假设也没有该域名的记录项，则查询microsoft.com所对应的二级名称服务器，然后把查询到的对应二级域名信息以一条DNS应答报文返回给DNS客户端（图中的A3）。 （7）DNS客户端在收到.com顶级名称服务器的DNS应答报文，得到microsoft.com二级域名所对应的二级名称服务器地址后，再次向对应的二级名称服务器发送一条解析example.microsoft.com域名的DNS请求报文（图中的Q4）。 （8）microsoft.com二级名称服务器在收到DNS客户端的DNS查询请求报文后，也先查询自己的缓存，假设也没有该域名的记录项，则查询example.microsoft.com所对应的权威名称服务器（因为这个名称服务器已包括了整个域名example.microsoft.com所在区域），然后把查询到的对应权威域名信息以一条DNS应答报文返回给DNS客户端（图中的A5）。 （9）DNS客户端在收到microsoft.com二级名称服务器的DNS应答报文，得到example.microsoft.com三级域名所对应的权威名称服务器地址后，再次向对应的权威名称服务器发送解析example.microsoft.com域名的DNS请求报文（图中的Q5）。 （10）权威名称服务器在收到DNS客户端的DNS查询请求报文后，在它的DNS区域数据库中查找，最终得出了example.microsoft.com域名所对应的IP地址。然后向DNS客户端返回一条DNS应答报文（图中的A5）。这样DNS客户端就可以正常访问这个网站了。 如果在步骤（10）中的对应域名的权威名称服务器都说找不到对应的域名记录，则会向DNS客户端返回一条查询失败的DNS应答报文。当然，如果这个权威名称服务器上配置了指向其它名称服务器的转发器，则权威名称服务器还会在转发器指向的名称服务器上进一步查询。另外，如果DNS客户端上配置了多个DNS服务器，则还会继续向其它DNS服务器查询的。","categories":[{"name":"网络","slug":"网络","permalink":"https://ydmxiaoyu.github.io/categories/网络/"}],"tags":[{"name":"dns","slug":"dns","permalink":"https://ydmxiaoyu.github.io/tags/dns/"}],"author":"xiaoyu"},{"title":"git命令总结","slug":"git命令总结","date":"2019-05-14T16:00:00.000Z","updated":"2019-06-26T09:29:35.928Z","comments":true,"path":"2019/05/15/git命令总结/","link":"","permalink":"https://ydmxiaoyu.github.io/2019/05/15/git命令总结/","excerpt":"","text":"git是非常优秀的开源分布式版本控制系统，它是在本地进行项目的版本管理的，每个人的电脑上都有一个完整的版本库，如果修改了自己电脑上的文件，只需要将文件推送到其他人就可以让对方看到你的修改了。相比较svn，它最大的特点就是不需要联网，所有操作都是在本地完成的，当然，如果要推送到远程仓库的话，就需要网络了。 这篇学习笔记总结了自己在学习git过程中使用的命令，以及其他的一些常用git命令。最后给出了git的官方中文文档链接。 配置123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 提交代码123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 公钥共存问题 gitlab 和 github 公钥共存 两个地方配置相同的公钥 链接 详情参考：git官方文档","categories":[{"name":"tools","slug":"tools","permalink":"https://ydmxiaoyu.github.io/categories/tools/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ydmxiaoyu.github.io/tags/git/"}],"author":"xiaoyu"},{"title":"Hello World","slug":"hello-world","date":"2019-05-09T16:00:00.000Z","updated":"2019-06-26T08:38:34.579Z","comments":true,"path":"2019/05/10/hello-world/","link":"","permalink":"https://ydmxiaoyu.github.io/2019/05/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hello","slug":"hello","permalink":"https://ydmxiaoyu.github.io/categories/hello/"}],"tags":[{"name":"hello","slug":"hello","permalink":"https://ydmxiaoyu.github.io/tags/hello/"}],"author":"xiaoyu"}]}